use super::Fp32;
use core::fmt;
use core::ops::{Add, AddAssign, Div, Sub, SubAssign};

/// Angle represented as an u16. One full turn is represented over the full 16bit range, meaning
/// that we have a precision of 360 / (2**16) -> 0.0055°
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub struct Angle(u16);

impl Angle {
    pub const DEG_180: Angle = Angle(1 << 15);
    pub const DEG_90: Angle = Angle(1 << 14);

    pub fn to_degrees(self) -> Fp32 {
        Fp32::from_s16_16(self.0 as i32) * 360
    }

    /// Convert the given angle into an Angle normalized to [0; 360°]
    pub fn from_degrees(degrees: Fp32) -> Angle {
        Angle((degrees / 360).to_s16_16() as u16)
    }

    /// Calculates the cotangent (1 / tan) of this angle
    pub fn cot(self) -> Fp32 {
        (Angle::DEG_90 - self).tan()
    }

    /// Calculate the tangent of this angle
    pub fn tan(self) -> Fp32 {
        let mut sign: i32 = 1;

        let mut a = self;

        if a.0 >= Angle::DEG_180.0 {
            a -= Angle::DEG_180;
        }

        if a.0 > Angle::DEG_90.0 {
            a = Angle::DEG_180 - a;
            sign = -1;
        }

        if a == Angle::DEG_90 {
            return 0.into();
        }

        // Linearly interpolate between values for added precision.
        let index = usize::from(a.0 >> 6);
        let f0 = u64::from(a.0 & ((1 << 6) - 1));
        let f1 = (1 << 6) - f0;

        let a = u64::from(TAN_LUT[index]);
        let b = u64::from(TAN_LUT[index + 1]);

        let cot = (f1 * a + f0 * b) >> 6;

        let cot = if cot > 0x7fff_ffff {
            Fp32::MAX
        } else {
            Fp32::from_s16_16(cot as i32)
        };

        cot.with_sign(sign)
    }

    pub fn sin(self) -> Fp32 {
        let mut sign: i32 = 1;

        let mut a = self;

        if a.0 >= Angle::DEG_180.0 {
            a -= Angle::DEG_180;
            sign = -1;
        }

        if a.0 > Angle::DEG_90.0 {
            a = Angle::DEG_180 - a;
        }

        if a == Angle::DEG_90 {
            return 1.into();
        }

        if a == Angle(0) {
            return 0.into();
        }

        // Linearly interpolate between values for added precision.
        let index = usize::from(a.0 >> 6);
        let f0 = u32::from(a.0 & ((1 << 6) - 1));
        let f1 = (1 << 6) - f0;

        let sin_a = u32::from(SIN_LUT[index]);
        let sin_b = u32::from(SIN_LUT[index + 1]);

        let sin_a = u32::from(sin_a);
        let sin_b = u32::from(sin_b);

        let sin = (f1 * sin_a + f0 * sin_b) >> 5;

        Fp32::from_s16_16(sin as i32).with_sign(sign)
    }

    pub fn cos(self) -> Fp32 {
        (self + Angle::DEG_90).sin()
    }
}

impl Add<Angle> for Angle {
    type Output = Angle;

    fn add(self, rhs: Angle) -> Angle {
        Angle(self.0.wrapping_add(rhs.0))
    }
}

impl AddAssign<Angle> for Angle {
    fn add_assign(&mut self, rhs: Angle) {
        *self = *self - rhs;
    }
}

impl Sub<Angle> for Angle {
    type Output = Angle;

    fn sub(self, rhs: Angle) -> Angle {
        Angle(self.0.wrapping_sub(rhs.0))
    }
}

impl SubAssign<Angle> for Angle {
    fn sub_assign(&mut self, rhs: Angle) {
        *self = *self - rhs;
    }
}

impl Div<u16> for Angle {
    type Output = Angle;

    fn div(self, rhs: u16) -> Angle {
        Angle(self.0 / rhs)
    }
}

impl fmt::Display for Angle {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.to_degrees().fmt(f)
    }
}

const SIN_LUT: [u16; 257] = [
    0x0, 0xc9, 0x192, 0x25b, 0x324, 0x3ed, 0x4b6, 0x57f, 0x647, 0x710, 0x7d9, 0x8a2, 0x96a, 0xa33,
    0xafb, 0xbc3, 0xc8b, 0xd53, 0xe1b, 0xee3, 0xfab, 0x1072, 0x1139, 0x1201, 0x12c8, 0x138e,
    0x1455, 0x151b, 0x15e2, 0x16a8, 0x176d, 0x1833, 0x18f8, 0x19bd, 0x1a82, 0x1b47, 0x1c0b, 0x1ccf,
    0x1d93, 0x1e56, 0x1f19, 0x1fdc, 0x209f, 0x2161, 0x2223, 0x22e5, 0x23a6, 0x2467, 0x2528, 0x25e8,
    0x26a8, 0x2767, 0x2826, 0x28e5, 0x29a3, 0x2a61, 0x2b1f, 0x2bdc, 0x2c98, 0x2d55, 0x2e11, 0x2ecc,
    0x2f87, 0x3041, 0x30fb, 0x31b5, 0x326e, 0x3326, 0x33de, 0x3496, 0x354d, 0x3604, 0x36ba, 0x376f,
    0x3824, 0x38d8, 0x398c, 0x3a40, 0x3af2, 0x3ba5, 0x3c56, 0x3d07, 0x3db8, 0x3e68, 0x3f17, 0x3fc5,
    0x4073, 0x4121, 0x41ce, 0x427a, 0x4325, 0x43d0, 0x447a, 0x4524, 0x45cd, 0x4675, 0x471c, 0x47c3,
    0x4869, 0x490f, 0x49b4, 0x4a58, 0x4afb, 0x4b9e, 0x4c3f, 0x4ce1, 0x4d81, 0x4e21, 0x4ebf, 0x4f5e,
    0x4ffb, 0x5097, 0x5133, 0x51ce, 0x5269, 0x5302, 0x539b, 0x5433, 0x54ca, 0x5560, 0x55f5, 0x568a,
    0x571d, 0x57b0, 0x5842, 0x58d4, 0x5964, 0x59f3, 0x5a82, 0x5b10, 0x5b9d, 0x5c29, 0x5cb4, 0x5d3e,
    0x5dc7, 0x5e50, 0x5ed7, 0x5f5e, 0x5fe3, 0x6068, 0x60ec, 0x616f, 0x61f1, 0x6271, 0x62f2, 0x6371,
    0x63ef, 0x646c, 0x64e8, 0x6563, 0x65dd, 0x6657, 0x66cf, 0x6746, 0x67bd, 0x6832, 0x68a6, 0x6919,
    0x698c, 0x69fd, 0x6a6d, 0x6adc, 0x6b4a, 0x6bb8, 0x6c24, 0x6c8f, 0x6cf9, 0x6d62, 0x6dca, 0x6e30,
    0x6e96, 0x6efb, 0x6f5f, 0x6fc1, 0x7023, 0x7083, 0x70e2, 0x7141, 0x719e, 0x71fa, 0x7255, 0x72af,
    0x7307, 0x735f, 0x73b5, 0x740b, 0x745f, 0x74b2, 0x7504, 0x7555, 0x75a5, 0x75f4, 0x7641, 0x768e,
    0x76d9, 0x7723, 0x776c, 0x77b4, 0x77fa, 0x7840, 0x7884, 0x78c7, 0x7909, 0x794a, 0x798a, 0x79c8,
    0x7a05, 0x7a42, 0x7a7d, 0x7ab6, 0x7aef, 0x7b26, 0x7b5d, 0x7b92, 0x7bc5, 0x7bf8, 0x7c29, 0x7c5a,
    0x7c89, 0x7cb7, 0x7ce3, 0x7d0f, 0x7d39, 0x7d62, 0x7d8a, 0x7db0, 0x7dd6, 0x7dfa, 0x7e1d, 0x7e3f,
    0x7e5f, 0x7e7f, 0x7e9d, 0x7eba, 0x7ed5, 0x7ef0, 0x7f09, 0x7f21, 0x7f38, 0x7f4d, 0x7f62, 0x7f75,
    0x7f87, 0x7f97, 0x7fa7, 0x7fb5, 0x7fc2, 0x7fce, 0x7fd8, 0x7fe1, 0x7fe9, 0x7ff0, 0x7ff6, 0x7ffa,
    0x7ffd, 0x7fff, 0x8000,
];

const TAN_LUT: [u32; 257] = [
    0x0, 0x192, 0x324, 0x4b6, 0x648, 0x7db, 0x96d, 0xb00, 0xc93, 0xe26, 0xfba, 0x114e, 0x12e2,
    0x1476, 0x160b, 0x17a0, 0x1936, 0x1acd, 0x1c63, 0x1dfb, 0x1f93, 0x212b, 0x22c4, 0x245e, 0x25f9,
    0x2794, 0x2930, 0x2acd, 0x2c6b, 0x2e0a, 0x2fa9, 0x314a, 0x32eb, 0x348e, 0x3632, 0x37d6, 0x397c,
    0x3b23, 0x3ccb, 0x3e75, 0x401f, 0x41cb, 0x4379, 0x4528, 0x46d8, 0x4889, 0x4a3d, 0x4bf1, 0x4da8,
    0x4f60, 0x5119, 0x52d5, 0x5492, 0x5651, 0x5811, 0x59d4, 0x5b99, 0x5d5f, 0x5f28, 0x60f3, 0x62c0,
    0x648f, 0x6660, 0x6833, 0x6a09, 0x6be2, 0x6dbc, 0x6f9a, 0x717a, 0x735c, 0x7541, 0x7729, 0x7914,
    0x7b01, 0x7cf2, 0x7ee5, 0x80dc, 0x82d5, 0x84d2, 0x86d2, 0x88d5, 0x8adc, 0x8ce6, 0x8ef4, 0x9105,
    0x931a, 0x9533, 0x9750, 0x9970, 0x9b95, 0x9dbe, 0x9feb, 0xa21c, 0xa451, 0xa68b, 0xa8ca, 0xab0d,
    0xad55, 0xafa2, 0xb1f4, 0xb44b, 0xb6a7, 0xb909, 0xbb70, 0xbddc, 0xc04e, 0xc2c6, 0xc544, 0xc7c8,
    0xca52, 0xcce3, 0xcf7a, 0xd218, 0xd4bc, 0xd767, 0xda1a, 0xdcd3, 0xdf94, 0xe25d, 0xe52d, 0xe806,
    0xeae6, 0xedcf, 0xf0c1, 0xf3bb, 0xf6be, 0xf9ca, 0xfce0, 0xffff, 0x10329, 0x1065c, 0x1099a,
    0x10ce2, 0x11035, 0x11394, 0x116fe, 0x11a73, 0x11df5, 0x12183, 0x1251e, 0x128c6, 0x12c7b,
    0x1303e, 0x13410, 0x137ef, 0x13bde, 0x13fdc, 0x143ea, 0x14808, 0x14c37, 0x15077, 0x154c9,
    0x1592d, 0x15da3, 0x1622d, 0x166cb, 0x16b7d, 0x17045, 0x17522, 0x17a16, 0x17f21, 0x18444,
    0x18980, 0x18ed5, 0x19444, 0x199cf, 0x19f76, 0x1a53a, 0x1ab1c, 0x1b11d, 0x1b73e, 0x1bd81,
    0x1c3e7, 0x1ca70, 0x1d11f, 0x1d7f4, 0x1def1, 0x1e617, 0x1ed69, 0x1f4e8, 0x1fc95, 0x20473,
    0x20c83, 0x214c8, 0x21d44, 0x225f8, 0x22ee9, 0x23817, 0x24186, 0x24b39, 0x25533, 0x25f78,
    0x26a09, 0x274ed, 0x28025, 0x28bb7, 0x297a7, 0x2a3fa, 0x2b0b5, 0x2bddd, 0x2cb78, 0x2d98d,
    0x2e823, 0x2f73f, 0x306ec, 0x31730, 0x32815, 0x339a5, 0x34beb, 0x35ef1, 0x372c6, 0x38776,
    0x39d10, 0x3b3a5, 0x3cb47, 0x3e40a, 0x3fe02, 0x41948, 0x435f7, 0x4542b, 0x47405, 0x495a9,
    0x4b93f, 0x4def6, 0x506ff, 0x53195, 0x55ef9, 0x58f74, 0x5c35d, 0x5fb14, 0x63709, 0x677bf,
    0x6bdcf, 0x709eb, 0x75ce6, 0x7b7bb, 0x81b97, 0x889e9, 0x9046d, 0x98d4c, 0xa2736, 0xad593,
    0xb9cc6, 0xc8289, 0xd8e81, 0xecb1a, 0x1046e9, 0x121702, 0x145aff, 0x17448c, 0x1b2671, 0x2095af,
    0x28bc48, 0x365199, 0x517bb5, 0xa2f8fd, 0x7fffffff,
];

#[test]
fn test_tan_lut() {
    let tlen = COT_LUT.len();

    for a in 0..tlen {
        use std::f64::consts::PI;

        let angle = (a as f64) * PI / (2. * ((tlen - 1) as f64));
        let fp_s16_16 = (f64::from(1 << 16) * angle.tan()) as i32;

        assert_eq!(fp_s16_16, COT_LUT[a])
    }
}
