use super::Fp32;
use core::fmt;
use core::ops::{Add, AddAssign, Div, Sub, SubAssign};

/// Angle represented as an u16. One full turn is represented over the full 16bit range, meaning
/// that we have a precision of 360 / (2**16) -> 0.0055°
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub struct Angle(u16);

impl Angle {
    pub const DEG_180: Angle = Angle(1 << 15);
    pub const DEG_90: Angle = Angle(1 << 14);

    pub fn to_degrees(self) -> Fp32 {
        Fp32::from_s16_16(self.0 as i32) * 360
    }

    /// Convert the given angle into an Angle normalized to [0; 360°]
    pub fn from_degrees(degrees: Fp32) -> Angle {
        Angle((degrees / 360).to_s16_16() as u16)
    }

    /// Calculates the cotangent (1 / tan) of this angle
    pub fn cot(self) -> Fp32 {
        (Angle::DEG_90 - self).tan()
    }

    /// Calculate the tangent of this angle
    pub fn tan(self) -> Fp32 {
        let mut sign: i32 = 1;

        let mut a = self;

        if a.0 >= Angle::DEG_180.0 {
            a -= Angle::DEG_180;
        }

        if a.0 > Angle::DEG_90.0 {
            a = Angle::DEG_180 - a;
            sign = -1;
        }

        if a == Angle::DEG_90 {
            return Fp32::MAX.with_sign(sign);
        }

        // Linearly interpolate between values for added precision.
        let index = usize::from(a.0 >> 6);
        let f0 = i32::from(a.0 & ((1 << 6) - 1));
        let f1 = (1 << 6) - f0;

        let a = i32::from(TAN_LUT[index]);
        let b = i32::from(TAN_LUT[index + 1]);

        let tan = (f1 * a + f0 * b) << 2;

        Fp32::from_s16_16(tan).with_sign(sign)
    }

    pub fn sin(self) -> Fp32 {
        let mut sign: i32 = 1;

        let mut a = self;

        if a.0 >= Angle::DEG_180.0 {
            a -= Angle::DEG_180;
            sign = -1;
        }

        if a.0 > Angle::DEG_90.0 {
            a = Angle::DEG_180 - a;
        }

        if a == Angle::DEG_90 {
            let one: Fp32 = 1.into();
            return one.with_sign(sign);
        }

        // Linearly interpolate between values for added precision.
        let index = usize::from(a.0 >> 6);
        let f0 = u32::from(a.0 & ((1 << 6) - 1));
        let f1 = (1 << 6) - f0;

        let sin_a = u32::from(SIN_LUT[index]);
        let sin_b = u32::from(SIN_LUT[index + 1]);

        let sin = (f1 * sin_a + f0 * sin_b) >> 5;

        Fp32::from_s16_16(sin as i32).with_sign(sign)
    }

    pub fn cos(self) -> Fp32 {
        (self + Angle::DEG_90).sin()
    }
}

impl Add<Angle> for Angle {
    type Output = Angle;

    fn add(self, rhs: Angle) -> Angle {
        Angle(self.0.wrapping_add(rhs.0))
    }
}

impl AddAssign<Angle> for Angle {
    fn add_assign(&mut self, rhs: Angle) {
        *self = *self + rhs;
    }
}

impl Sub<Angle> for Angle {
    type Output = Angle;

    fn sub(self, rhs: Angle) -> Angle {
        Angle(self.0.wrapping_sub(rhs.0))
    }
}

impl SubAssign<Angle> for Angle {
    fn sub_assign(&mut self, rhs: Angle) {
        *self = *self - rhs;
    }
}

impl Div<u16> for Angle {
    type Output = Angle;

    fn div(self, rhs: u16) -> Angle {
        Angle(self.0 / rhs)
    }
}

impl fmt::Display for Angle {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.to_degrees().fmt(f)
    }
}

const TAN_LUT: [u16; 257] = [
    0x0, 0x2, 0x3, 0x5, 0x6, 0x8, 0x9, 0xb, 0xd, 0xe, 0x10, 0x11, 0x13, 0x14, 0x16, 0x18, 0x19,
    0x1b, 0x1c, 0x1e, 0x20, 0x21, 0x23, 0x24, 0x26, 0x28, 0x29, 0x2b, 0x2c, 0x2e, 0x30, 0x31, 0x33,
    0x35, 0x36, 0x38, 0x39, 0x3b, 0x3d, 0x3e, 0x40, 0x42, 0x43, 0x45, 0x47, 0x49, 0x4a, 0x4c, 0x4e,
    0x4f, 0x51, 0x53, 0x55, 0x56, 0x58, 0x5a, 0x5c, 0x5d, 0x5f, 0x61, 0x63, 0x65, 0x66, 0x68, 0x6a,
    0x6c, 0x6e, 0x70, 0x71, 0x73, 0x75, 0x77, 0x79, 0x7b, 0x7d, 0x7f, 0x81, 0x83, 0x85, 0x87, 0x89,
    0x8b, 0x8d, 0x8f, 0x91, 0x93, 0x95, 0x97, 0x99, 0x9c, 0x9e, 0xa0, 0xa2, 0xa4, 0xa7, 0xa9, 0xab,
    0xad, 0xb0, 0xb2, 0xb4, 0xb7, 0xb9, 0xbb, 0xbe, 0xc0, 0xc3, 0xc5, 0xc8, 0xca, 0xcd, 0xcf, 0xd2,
    0xd5, 0xd7, 0xda, 0xdd, 0xe0, 0xe2, 0xe5, 0xe8, 0xeb, 0xee, 0xf1, 0xf4, 0xf7, 0xfa, 0xfd,
    0x100, 0x103, 0x106, 0x10a, 0x10d, 0x110, 0x114, 0x117, 0x11a, 0x11e, 0x122, 0x125, 0x129,
    0x12c, 0x130, 0x134, 0x138, 0x13c, 0x140, 0x144, 0x148, 0x14c, 0x150, 0x155, 0x159, 0x15e,
    0x162, 0x167, 0x16b, 0x170, 0x175, 0x17a, 0x17f, 0x184, 0x18a, 0x18f, 0x194, 0x19a, 0x19f,
    0x1a5, 0x1ab, 0x1b1, 0x1b7, 0x1be, 0x1c4, 0x1ca, 0x1d1, 0x1d8, 0x1df, 0x1e6, 0x1ed, 0x1f5,
    0x1fd, 0x204, 0x20d, 0x215, 0x21d, 0x226, 0x22f, 0x238, 0x242, 0x24b, 0x255, 0x25f, 0x26a,
    0x275, 0x280, 0x28c, 0x298, 0x2a4, 0x2b1, 0x2be, 0x2cb, 0x2da, 0x2e8, 0x2f7, 0x307, 0x317,
    0x328, 0x33a, 0x34c, 0x35f, 0x373, 0x387, 0x39d, 0x3b4, 0x3cb, 0x3e4, 0x3fe, 0x419, 0x436,
    0x454, 0x474, 0x496, 0x4b9, 0x4df, 0x507, 0x532, 0x55f, 0x58f, 0x5c3, 0x5fb, 0x637, 0x678,
    0x6be, 0x70a, 0x75d, 0x7b8, 0x81c, 0x88a, 0x904, 0x98d, 0xa27, 0xad6, 0xb9d, 0xc83, 0xd8f,
    0xecb, 0x1047, 0x1217, 0x145b, 0x1745, 0x1b26, 0x2096, 0x28bc, 0x3652, 0x517c, 0xa2f9, 0xffff,
];

const SIN_LUT: [u16; 257] = [
    0x0, 0xc9, 0x192, 0x25b, 0x324, 0x3ed, 0x4b6, 0x57f, 0x648, 0x711, 0x7d9, 0x8a2, 0x96b, 0xa33,
    0xafb, 0xbc4, 0xc8c, 0xd54, 0xe1c, 0xee4, 0xfab, 0x1073, 0x113a, 0x1201, 0x12c8, 0x138f,
    0x1455, 0x151c, 0x15e2, 0x16a8, 0x176e, 0x1833, 0x18f9, 0x19be, 0x1a83, 0x1b47, 0x1c0c, 0x1cd0,
    0x1d93, 0x1e57, 0x1f1a, 0x1fdd, 0x209f, 0x2162, 0x2224, 0x22e5, 0x23a7, 0x2467, 0x2528, 0x25e8,
    0x26a8, 0x2768, 0x2827, 0x28e5, 0x29a4, 0x2a62, 0x2b1f, 0x2bdc, 0x2c99, 0x2d55, 0x2e11, 0x2ecc,
    0x2f87, 0x3042, 0x30fc, 0x31b5, 0x326e, 0x3327, 0x33df, 0x3497, 0x354e, 0x3604, 0x36ba, 0x3770,
    0x3825, 0x38d9, 0x398d, 0x3a40, 0x3af3, 0x3ba5, 0x3c57, 0x3d08, 0x3db8, 0x3e68, 0x3f17, 0x3fc6,
    0x4074, 0x4121, 0x41ce, 0x427a, 0x4326, 0x43d1, 0x447b, 0x4524, 0x45cd, 0x4675, 0x471d, 0x47c4,
    0x486a, 0x490f, 0x49b4, 0x4a58, 0x4afb, 0x4b9e, 0x4c40, 0x4ce1, 0x4d81, 0x4e21, 0x4ec0, 0x4f5e,
    0x4ffb, 0x5098, 0x5134, 0x51cf, 0x5269, 0x5303, 0x539b, 0x5433, 0x54ca, 0x5560, 0x55f6, 0x568a,
    0x571e, 0x57b1, 0x5843, 0x58d4, 0x5964, 0x59f4, 0x5a82, 0x5b10, 0x5b9d, 0x5c29, 0x5cb4, 0x5d3e,
    0x5dc8, 0x5e50, 0x5ed7, 0x5f5e, 0x5fe4, 0x6068, 0x60ec, 0x616f, 0x61f1, 0x6272, 0x62f2, 0x6371,
    0x63ef, 0x646c, 0x64e9, 0x6564, 0x65de, 0x6657, 0x66d0, 0x6747, 0x67bd, 0x6832, 0x68a7, 0x691a,
    0x698c, 0x69fd, 0x6a6e, 0x6add, 0x6b4b, 0x6bb8, 0x6c24, 0x6c8f, 0x6cf9, 0x6d62, 0x6dca, 0x6e31,
    0x6e97, 0x6efb, 0x6f5f, 0x6fc2, 0x7023, 0x7083, 0x70e3, 0x7141, 0x719e, 0x71fa, 0x7255, 0x72af,
    0x7308, 0x735f, 0x73b6, 0x740b, 0x7460, 0x74b3, 0x7505, 0x7556, 0x75a6, 0x75f4, 0x7642, 0x768e,
    0x76d9, 0x7723, 0x776c, 0x77b4, 0x77fb, 0x7840, 0x7885, 0x78c8, 0x790a, 0x794a, 0x798a, 0x79c9,
    0x7a06, 0x7a42, 0x7a7d, 0x7ab7, 0x7aef, 0x7b27, 0x7b5d, 0x7b92, 0x7bc6, 0x7bf9, 0x7c2a, 0x7c5a,
    0x7c89, 0x7cb7, 0x7ce4, 0x7d0f, 0x7d3a, 0x7d63, 0x7d8a, 0x7db1, 0x7dd6, 0x7dfb, 0x7e1e, 0x7e3f,
    0x7e60, 0x7e7f, 0x7e9d, 0x7eba, 0x7ed6, 0x7ef0, 0x7f0a, 0x7f22, 0x7f38, 0x7f4e, 0x7f62, 0x7f75,
    0x7f87, 0x7f98, 0x7fa7, 0x7fb5, 0x7fc2, 0x7fce, 0x7fd9, 0x7fe2, 0x7fea, 0x7ff1, 0x7ff6, 0x7ffa,
    0x7ffe, 0x7fff, 0x8000,
];

#[test]
fn test_sin_lut() {
    let tlen = TAN_LUT.len();

    for a in 0..tlen {
        use std::f64::consts::PI;

        let angle = (a as f64) * PI / (2. * ((tlen - 1) as f64));
        let fp_s16_16 = (f64::from(1 << 15) * angle.sin() + 0.5) as u16;

        assert_eq!(fp_s16_16, SIN_LUT[a])
    }
}

#[test]
fn test_tan_lut() {
    let tlen = TAN_LUT.len();

    for a in 0..tlen {
        use std::f64::consts::PI;

        let angle = (a as f64) * PI / (2. * ((tlen - 1) as f64));
        let fp_s16_16 = (f64::from(1 << 8) * angle.tan() + 0.5) as u16;

        assert_eq!(fp_s16_16, TAN_LUT[a])
    }
}
