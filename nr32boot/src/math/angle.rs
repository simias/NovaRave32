use super::Fp32;
use core::fmt;
use core::ops::{Div, Sub, SubAssign};

/// Angle represented as an u16. One full turn is represented over the full 16bit range, meaning
/// that we have a precision of 360 / (2**16) -> 0.0055°
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub struct Angle(u16);

impl Angle {
    pub const DEG_180: Angle = Angle(1 << 15);
    pub const DEG_90: Angle = Angle(1 << 14);

    pub fn to_degrees(self) -> Fp32 {
        Fp32::from_s16_16(self.0 as i32) * 360
    }

    /// Convert the given angle into an Angle normalized to [0; 360°]
    pub fn from_degrees(degrees: Fp32) -> Angle {
        Angle((degrees / 360).to_s16_16() as u16)
    }

    /// Calculate the cotangent of this angle. The approach is LUT-based which isn't great at very
    /// low angles.
    pub fn cot(self) -> Fp32 {
        let mut sign: i32 = 1;

        let mut a = self;

        if a.0 >= Angle::DEG_180.0 {
            a -= Angle::DEG_180;
        }

        if a.0 > Angle::DEG_90.0 {
            a = Angle::DEG_180 - a;
            sign = -1;
        }

        if a == Angle::DEG_90 {
            return 0.into();
        }

        // Linearly interpolate between values for added precision.
        let index = usize::from(a.0 >> 6);
        let f0 = u64::from(a.0 & ((1 << 6) - 1));
        let f1 = (1 << 6) - f0;

        let a = u64::from(COT_LUT[index]);
        let b = u64::from(COT_LUT[index + 1]);

        let cot = (f1 * a + f0 * b) >> 6;

        let cot = if cot > 0x7fff_ffff {
            Fp32::MAX
        } else {
            Fp32::from_s16_16(cot as i32)
        };

        cot.with_sign(sign)
    }
}

impl Sub<Angle> for Angle {
    type Output = Angle;

    fn sub(self, rhs: Angle) -> Angle {
        Angle(self.0.wrapping_sub(rhs.0))
    }
}

impl SubAssign<Angle> for Angle {
    fn sub_assign(&mut self, rhs: Angle) {
        *self = *self - rhs;
    }
}

impl Div<u16> for Angle {
    type Output = Angle;

    fn div(self, rhs: u16) -> Angle {
        Angle(self.0 / rhs)
    }
}

impl fmt::Display for Angle {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.to_degrees().fmt(f)
    }
}

const COT_LUT: [u32; 257] = [
    0x7fffffff, 0xa2f8fd, 0x517bb5, 0x365199, 0x28bc48, 0x2095af, 0x1b2671, 0x17448c, 0x145aff,
    0x121702, 0x1046e9, 0xecb1a, 0xd8e81, 0xc8289, 0xb9cc6, 0xad593, 0xa2736, 0x98d4c, 0x9046d,
    0x889e9, 0x81b97, 0x7b7bb, 0x75ce6, 0x709eb, 0x6bdcf, 0x677bf, 0x63709, 0x5fb14, 0x5c35d,
    0x58f74, 0x55ef9, 0x53195, 0x506ff, 0x4def6, 0x4b93f, 0x495a9, 0x47405, 0x4542b, 0x435f7,
    0x41948, 0x3fe02, 0x3e40a, 0x3cb47, 0x3b3a5, 0x39d10, 0x38776, 0x372c6, 0x35ef1, 0x34beb,
    0x339a5, 0x32815, 0x31730, 0x306ec, 0x2f73f, 0x2e823, 0x2d98d, 0x2cb78, 0x2bddd, 0x2b0b5,
    0x2a3fa, 0x297a7, 0x28bb7, 0x28025, 0x274ed, 0x26a09, 0x25f78, 0x25533, 0x24b39, 0x24186,
    0x23817, 0x22ee9, 0x225f8, 0x21d44, 0x214c8, 0x20c83, 0x20473, 0x1fc95, 0x1f4e8, 0x1ed69,
    0x1e617, 0x1def1, 0x1d7f4, 0x1d11f, 0x1ca70, 0x1c3e7, 0x1bd81, 0x1b73e, 0x1b11d, 0x1ab1c,
    0x1a53a, 0x19f76, 0x199cf, 0x19444, 0x18ed5, 0x18980, 0x18444, 0x17f21, 0x17a16, 0x17522,
    0x17045, 0x16b7d, 0x166cb, 0x1622d, 0x15da3, 0x1592d, 0x154c9, 0x15077, 0x14c37, 0x14808,
    0x143ea, 0x13fdc, 0x13bde, 0x137ef, 0x13410, 0x1303e, 0x12c7b, 0x128c6, 0x1251e, 0x12183,
    0x11df5, 0x11a73, 0x116fe, 0x11394, 0x11035, 0x10ce2, 0x1099a, 0x1065c, 0x10329, 0x10000,
    0xfce0, 0xf9ca, 0xf6be, 0xf3bb, 0xf0c1, 0xedcf, 0xeae6, 0xe806, 0xe52d, 0xe25d, 0xdf94, 0xdcd3,
    0xda1a, 0xd767, 0xd4bc, 0xd218, 0xcf7a, 0xcce3, 0xca52, 0xc7c8, 0xc544, 0xc2c6, 0xc04e, 0xbddc,
    0xbb70, 0xb909, 0xb6a7, 0xb44b, 0xb1f4, 0xafa2, 0xad55, 0xab0d, 0xa8ca, 0xa68b, 0xa451, 0xa21c,
    0x9feb, 0x9dbe, 0x9b95, 0x9970, 0x9750, 0x9533, 0x931a, 0x9105, 0x8ef4, 0x8ce6, 0x8adc, 0x88d5,
    0x86d2, 0x84d2, 0x82d5, 0x80dc, 0x7ee5, 0x7cf2, 0x7b01, 0x7914, 0x7729, 0x7541, 0x735c, 0x717a,
    0x6f9a, 0x6dbc, 0x6be2, 0x6a09, 0x6833, 0x6660, 0x648f, 0x62c0, 0x60f3, 0x5f28, 0x5d5f, 0x5b99,
    0x59d4, 0x5811, 0x5651, 0x5492, 0x52d5, 0x5119, 0x4f60, 0x4da8, 0x4bf1, 0x4a3d, 0x4889, 0x46d8,
    0x4528, 0x4379, 0x41cb, 0x401f, 0x3e75, 0x3ccb, 0x3b23, 0x397c, 0x37d6, 0x3632, 0x348e, 0x32eb,
    0x314a, 0x2fa9, 0x2e0a, 0x2c6b, 0x2acd, 0x2930, 0x2794, 0x25f9, 0x245e, 0x22c4, 0x212b, 0x1f93,
    0x1dfb, 0x1c63, 0x1acd, 0x1936, 0x17a0, 0x160b, 0x1476, 0x12e2, 0x114e, 0xfba, 0xe26, 0xc93,
    0xb00, 0x96d, 0x7db, 0x648, 0x4b6, 0x324, 0x192, 0x0,
];

#[test]
fn test_cotan_lut() {
    let tlen = COT_LUT.len();

    for a in 0..tlen {
        use std::f64::consts::PI;

        let angle = (a as f64) * PI / (2. * ((tlen - 1) as f64));
        let fp_s16_16 = (f64::from(1 << 16) / angle.tan()) as i32;

        assert_eq!(fp_s16_16, COT_LUT[a])
    }
}
